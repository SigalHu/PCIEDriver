#include "driver.h"
#include "Interrupt.tmh"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, PcieInterruptCreate)
#endif

NTSTATUS
PcieInterruptCreate(
	_In_ PDEVICE_CONTEXT DevExt
	)
/*++
Routine Description:

Configure and create the WDFINTERRUPT object.
This routine is called by EvtDeviceAdd callback.

Arguments:

DevExt      Pointer to our DEVICE_EXTENSION

Return Value:

NTSTATUS code

--*/
{
	NTSTATUS  status = STATUS_SUCCESS;
	WDF_INTERRUPT_CONFIG        InterruptConfig;

	PAGED_CODE();

#ifdef DEBUG_HU
	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "--> %!FUNC!");
#endif

	WDF_INTERRUPT_CONFIG_INIT(&InterruptConfig,
		PcieEvtInterruptIsr,
		PcieEvtInterruptDpc);

	InterruptConfig.EvtInterruptEnable = PcieEvtInterruptEnable;
	InterruptConfig.EvtInterruptDisable = PcieEvtInterruptDisable;

	// JOHNR: Enable testing of the DpcForIsr Synchronization
	InterruptConfig.AutomaticSerialization = TRUE;

	//
	// Unlike WDM, framework driver should create interrupt object in EvtDeviceAdd and
	// let the framework do the resource parsing and registration of ISR with the kernel.
	// Framework connects the interrupt after invoking the EvtDeviceD0Entry callback
	// and disconnect before invoking EvtDeviceD0Exit. EvtInterruptEnable is called after
	// the interrupt interrupt is connected and EvtInterruptDisable before the interrupt is
	// disconnected.
	//
	status = WdfInterruptCreate(DevExt->Device,
		&InterruptConfig,
		WDF_NO_OBJECT_ATTRIBUTES,
		&DevExt->Interrupt);

	if (!NT_SUCCESS(status)) {
#ifdef DEBUG_HU
		TraceEvents(TRACE_LEVEL_ERROR, TRACE_DRIVER,
			"WdfInterruptCreate failed: %!STATUS!", status);
#endif
		return status;
	}

#ifdef DEBUG_HU
	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "<-- %!FUNC!");
#endif
	return status;
}

BOOLEAN
PcieEvtInterruptIsr(
	_In_ WDFINTERRUPT Interrupt,
	_In_ ULONG        MessageID
	)
/*++
Routine Description:

Interrupt handler for this driver. Called at DIRQL level when the
device or another device sharing the same interrupt line asserts
the interrupt. The driver first checks the device to make sure whether
this interrupt is generated by its device and if so clear the interrupt
register to disable further generation of interrupts and queue a
DPC to do other I/O work related to interrupt - such as reading
the device memory, starting a DMA transaction, coping it to
the request buffer and completing the request, etc.

Arguments:

Interupt   - Handle to WDFINTERRUPT Object for this device.
MessageID  - MSI message ID (always 0 in this configuration)

Return Value:

TRUE   --  This device generated the interrupt.
FALSE  --  This device did not generated this interrupt.

--*/
{
	BOOLEAN             isRecognized = FALSE;
	PDEVICE_CONTEXT     devExt;
	ULONG               intStatus;

	UNREFERENCED_PARAMETER(MessageID);

#ifdef DEBUG_HU
	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "--> %!FUNC!");
#endif

	devExt = PcieGetDeviceContext(WdfInterruptGetDevice(Interrupt));
	if (devExt->MemBarBase){
		intStatus = PcieDeviceGetInterrupt(devExt->MemBarBase);

		if (intStatus){
			PcieDeviceDisableInterrupt(devExt->MemBarBase);
			PcieDeviceClearInterrupt(devExt->MemBarBase);
			devExt->IntStatus = intStatus;
			WdfInterruptQueueDpcForIsr(devExt->Interrupt);
			isRecognized = TRUE;
		}
	}

#ifdef DEBUG_HU
	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "<-- %!FUNC!");
#endif
	return isRecognized;
}

VOID
PcieEvtInterruptDpc(
	_In_ WDFINTERRUPT Interrupt,
	_In_ WDFDEVICE    Device
)
/*++

Routine Description:

DPC callback for ISR. Please note that on a multiprocessor system,
you could have more than one DPCs running simulataneously on
multiple processors. So if you are accesing any global resources
make sure to synchrnonize the accesses with a spinlock.

Arguments:

Interupt  - Handle to WDFINTERRUPT Object for this device.
Device    - WDFDEVICE object passed to InterruptCreate

Return Value:

--*/
{
	PDEVICE_CONTEXT     devExt;

	UNREFERENCED_PARAMETER(Device);

#ifdef DEBUG_HU
	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "--> %!FUNC!");
#endif

	devExt = PcieGetDeviceContext(WdfInterruptGetDevice(Interrupt));

	//
	// Check interrupt from user FPGA
	//
	if (devExt->IntStatus & INT_FLAG_FPGA_TRIG){
#ifdef DEBUG_HU
		TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "Got user FPGA interrupt");
#endif
	}

	//
	// Check interrupt for DMA transfer end
	//
	if (devExt->IntStatus & INT_FLAG_DMA_END){
#ifdef DEBUG_HU
		TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "Got DMA transfer end interrupt");
#endif

		if (devExt->DmaMode.bits.RdWr == TRUE){
			// Acquire lock
			WdfInterruptAcquireLock(Interrupt);

			PcieDMATimerStop(devExt->WriteTimer);
			if (devExt->WriteTimeout){
				WdfInterruptReleaseLock(Interrupt);
#ifdef DEBUG_HU
				TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER,
					"Captured WriteTimeout in the DpcForIsr");
#endif
				return;
			}

			// Release lock
			WdfInterruptReleaseLock(Interrupt);

			WdfRequestCompleteWithInformation(devExt->WriteRequest, STATUS_SUCCESS, devExt->WriteDmaLength);
#ifdef DEBUG_HU
			TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER,
				"DMA complete write transfer %d bytes\n", 
				devExt->WriteDmaLength);
#endif
		}
		else {
			// Acquire lock
			WdfInterruptAcquireLock(Interrupt);

			PcieDMATimerStop(devExt->ReadTimer);
			if (devExt->ReadTimeout){
				WdfInterruptReleaseLock(Interrupt);
#ifdef DEBUG_HU
				TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER,
					"Captured WriteTimeout in the DpcForIsr");
#endif
				return;
			}

			// Release lock
			WdfInterruptReleaseLock(Interrupt);

			if (devExt->ReadBuffer != NULL && devExt->CommonBufferBase != NULL){
				RtlCopyMemory(devExt->ReadBuffer, devExt->CommonBufferBase, devExt->ReadDmaLength);
				KeMemoryBarrier();
			}
			WdfRequestCompleteWithInformation(devExt->ReadRequest, STATUS_SUCCESS, devExt->ReadDmaLength);
#ifdef DEBUG_HU
			TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER,
				"DMA complete read transfer %d bytes\n",
				devExt->WriteDmaLength);
#endif
		}
	}

#ifdef DEBUG_HU
	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "<-- %!FUNC!");
#endif
}

NTSTATUS
PcieEvtInterruptEnable(
	_In_ WDFINTERRUPT Interrupt,
	_In_ WDFDEVICE    Device
	)
/*++

Routine Description:

Called by the framework at DIRQL immediately after registering the ISR with the kernel
by calling IoConnectInterrupt.

Return Value:

NTSTATUS
--*/
{
	NTSTATUS  status = STATUS_SUCCESS;
	PDEVICE_CONTEXT  	devExt;

	UNREFERENCED_PARAMETER(Device);

#ifdef DEBUG_HU
	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "--> %!FUNC!");
#endif

	devExt = PcieGetDeviceContext(WdfInterruptGetDevice(Interrupt));
	if (devExt->MemBarBase){
		PcieDeviceEnableInterrupt(devExt->MemBarBase);
	}

#ifdef DEBUG_HU
	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "<-- %!FUNC!");
#endif
	return status;
}

NTSTATUS
PcieEvtInterruptDisable(
	_In_ WDFINTERRUPT Interrupt,
	_In_ WDFDEVICE    Device
	)
/*++

Routine Description:

Called by the framework at DIRQL before Deregistering the ISR with the kernel
by calling IoDisconnectInterrupt.

Return Value:

NTSTATUS
--*/
{
	NTSTATUS  status = STATUS_SUCCESS;
	PDEVICE_CONTEXT  	devExt;

	UNREFERENCED_PARAMETER(Device);

#ifdef DEBUG_HU
	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "--> %!FUNC!");
#endif

	devExt = PcieGetDeviceContext(WdfInterruptGetDevice(Interrupt));
	if (devExt->MemBarBase){
		PcieDeviceDisableInterrupt(devExt->MemBarBase);
	}

#ifdef DEBUG_HU
	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "<-- %!FUNC!");
#endif
	return status;
}